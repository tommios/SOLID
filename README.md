# SOLID
                      Examples of the implementation of the principles of SOLID on JavaScript


### <pre>S - *The Single Responsibility Principle*   ( SRP )  Принцип единственной ответственности;</pre>
<p>Класс должен быть ответственен лишь за что-то одно. Если класс отвечает за решение нескольких задач, его подсистемы, реализующие решение этих задач, оказываются связанными друг с другом. Изменения в одной такой подсистеме ведут к изменениям в другой.</p>  

### <pre>O - *The Open Closed Principle*             ( OCP )  Принцип открытости/закрытости;</pre>  
<p>Программные сущности (классы, модули, функции) должны быть открыты для расширения, но не для модификации.</p>  

### <pre>L - *The Liskov Substitution Principle*     ( LSP )  Принцип подстановки Барбары Лисков;</pre>  
<p>Необходимо, чтобы подклассы могли бы служить заменой для своих суперклассов.</p>  
<p>Цель этого принципа заключаются в том, чтобы классы-наследники могли бы использоваться вместо родительских классов, от которых они образованы, не нарушая работу программы. Если оказывается, что в коде проверяется тип класса, значит принцип подстановки нарушается.</p>  
  
### <pre>I - *The Interface Segregation Principle*   ( ISP )  Принцип разделения интерфейса;</pre>  
<p>Создавайте узкоспециализированные интерфейсы, предназначенные для конкретного клиента. Клиенты не должны зависеть от интерфейсов, которые они не используют.</p>  
<p>Этот принцип направлен на устранение недостатков, связанных с реализацией больших интерфейсов.</p>  

### <pre>D - *The Dependency Inversion Principle*    ( DIP )  Принцип инверсии зависимостей.</pre>  
<p>Объектом зависимости должна быть абстракция, а не что-то конкретное.</p>
<ol>
    <li>Модули верхних уровней не должны зависеть от модулей нижних уровней. Оба типа модулей должны зависеть от абстракций.</li>
    <li>Абстракции не должны зависеть от деталей. Детали должны зависеть от абстракций.</li>
</ol>
<p>В процессе разработки программного обеспечения существует момент, когда функционал приложения перестаёт помещаться в рамках одного модуля. Когда это происходит, нам приходится решать проблему зависимостей модулей. В результате, например, может оказаться так, что высокоуровневые компоненты зависят от низкоуровневых компонентов.</p>
