# SOLID
                      Examples of the implementation of the principles of SOLID on JavaScript


### <pre>S - *The Single Responsibility Principle*   ( SRP )  Принцип единственной ответственности;</pre>
<p>Класс должен быть ответственен лишь за что-то одно. Если класс отвечает за решение нескольких задач, его подсистемы, реализующие решение этих задач, оказываются связанными друг с другом. Изменения в одной такой подсистеме ведут к изменениям в другой.</p>  
<p>Для каждого класса должно быть определено единственное назначение. Все ресурсы, необходимые для его осуществления, должны быть инкапсулированы в этот класс и подчинены только этой задаче.</p>  

### <pre>O - *The Open Closed Principle*             ( OCP )  Принцип открытости/закрытости;</pre>  
<p>Программные сущности (классы, модули, функции) должны быть открыты для расширения, но не для модификации.</p>  

### <pre>L - *The Liskov Substitution Principle*     ( LSP )  Принцип подстановки Барбары Лисков;</pre>  
<p>Необходимо, чтобы подклассы могли бы служить заменой для своих суперклассов.</p>  
<p>Цель этого принципа заключаются в том, чтобы классы-наследники могли бы использоваться вместо родительских классов, от которых они образованы, не нарушая работу программы. Если оказывается, что в коде проверяется тип класса, значит принцип подстановки нарушается.</p>  
  
### <pre>I - *The Interface Segregation Principle*   ( ISP )  Принцип разделения интерфейса;</pre>  
<p>Создавайте узкоспециализированные интерфейсы, предназначенные для конкретного клиента. Клиенты не должны зависеть от интерфейсов, которые они не используют.</p>  
<p>Этот принцип направлен на устранение недостатков, связанных с реализацией больших интерфейсов.</p>  
<p>Предпочтительнее разделять интерфейсы на более мелкие тематические, чтобы реализующие их классы не были вынуждены определять методы, которые непосредственно в них не используются.</p>

### <pre>D - *The Dependency Inversion Principle*    ( DIP )  Принцип инверсии зависимостей.</pre>  
<p>Объектом зависимости должна быть абстракция, а не что-то конкретное.</p>
<ol>
    <li>Модули верхних уровней не должны зависеть от модулей нижних уровней. Оба типа модулей должны зависеть от абстракций.</li>
    <li>Абстракции не должны зависеть от деталей. Детали должны зависеть от абстракций.</li>
</ol>
<p>В процессе разработки программного обеспечения существует момент, когда функционал приложения перестаёт помещаться в рамках одного модуля. Когда это происходит, нам приходится решать проблему зависимостей модулей. В результате, например, может оказаться так, что высокоуровневые компоненты зависят от низкоуровневых компонентов.</p>

## Базовые принципы ООП  
<ul>
    <li><strong>Абстракция</strong> — отделение концепции от ее экземпляра;</li>
    <li><strong>Полиморфизм</strong> — реализация задач одной и той же идеи разными способами;</li>
    <li><strong>Наследование</strong> — способность объекта или класса базироваться на другом объекте или классе. Это главный механизм для повторного использования кода. Наследственное отношение классов четко определяет их иерархию;</li>
    <li><strong>Инкапсуляция</strong> — размещение одного объекта или класса внутри другого для разграничения доступа к ним.</li>
</ul>

### Используйте следующее вместе с наследованием  
<ul>
    <li><strong>Делегация</strong> — перепоручение задачи от внешнего объекта внутреннему;</li>
    <li><strong>Композиция</strong> — включение объектом-контейнером объекта-содержимого и управление его поведением; последний не может существовать вне первого;</li>
    <li><strong>Агрегация</strong> — включение объектом-контейнером ссылки на объект-содержимое; при уничтожении первого последний продолжает существование.</li> 
</ul>